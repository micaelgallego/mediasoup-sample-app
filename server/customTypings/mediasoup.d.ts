declare module 'mediasoup' {

    import { EventEmitter } from "events";

    //NOTE: It is not possible to have simple inheritance for events due to limitation in TypeScript (https://github.com/Microsoft/TypeScript/issues/10229)

    //TODO
    // X Define MediaKind enum ("audio" | "video") if it is finally reified in documentation
    // X It is useful to extend from EventEmitter in observers?
    // X Find a way to document method parameters defined as objects. Putting the commment on top of the property in params object is not reflected in VSCode GUI. It would be good to visit while exploring
    // X Custom data in transports or consumers/producers is really readonly or can be changed? (Contradictory docs)
    // In documentation, PipeTransport property 'sctpParameters' is of type SctpParameters, but looking for definition is of type TransportSctpParameters. Where is the type?
    // * Property 'direction' in RtpHeaderExtension is of type '"sendrecv" | "sendonly" | "recvonly"' instead of plain string. It is ok?
    // listenIps property in WebRtcTransportOptions is of type 'TransportListenIp[] | TransportListenIp | string;'. But I've tested passing only an object of TransportListenIp and raises an error "missing listenIps".


    const mediasoup: MediaSoup;

    export default mediasoup;

    export interface MediaSoup {

        /**The media soup version */
        readonly version: string;

        /**An event emitter that allows the application (or third party libraries) monitor Worker instances created by the application. See the Observer Events section below. */
        readonly observer: Readonly<MediaSoupObserver>; //TODO: Extends EventEmitter definition.

        /**Creates a new worker with the given settings. */
        createWorker<AppDataT>(options: WorkerSettings): Promise<Worker>;

        /**Returns a cloned copy of the mediasoup supported RTP capabilities, specifically the content of the mediasoup/lib/supportedRtpCapabilities.js file. */
        getSupportedRtpCapabilities(): RtpCapabilities;

        /**Parses the given scalabilityMode string according to the rules in webrtc-svc. */
        parseScalabilityMode(scalabilityMode?: string): ScalabilityMode;
    }

    export interface MediaSoupObserver extends EventEmitter {
        /**Emitted when a new worker is created. */
        on(eventType: "newworker", handler: (worker: Worker) => void): this;
    }

    export interface ScalabilityMode {
        /**Number of spatial layers (by default 1) */
        spatialLayers: number;
        /**Number of temporal layers (by default 1) */
        temporalLayers: number;
    }

    export interface WorkerSettings {
        /**Logging level for logs generated by the media worker subprocesses (check the Debugging documentation). Valid values are "debug", "warn", "error" and "none". Default "error" */
        logLevel?: "debug" | "warn" | "error" | "none";

        /**Log tags for debugging. Check the list of available tags in Debugging documentation. Default [] */
        logTags?: string[];

        /**Minimun RTC port for ICE, DTLS, RTP, etc. Default 10000 */
        rtcMinPort?: number;

        /**Maximum RTC port for ICE, DTLS, RTP, etc. Default 59999 */
        rtcMaxPort?: number;

        /**Path to the DTLS public certificate file in PEM format. If unset, a certificate is dynamically created.*/
        dtlsCertificateFile?: string;

        /**Path to the DTLS certificate private key file in PEM format. If unset, a certificate is dynamically created.*/
        dtlsPrivateKeyFile?: string;
    }

    export type WorkerUpdateableSettings = Pick<WorkerSettings, 'logLevel' | 'logTags'>;

    /**A worker represents a mediasoup C++ subprocess that runs in a single CPU core and handles Router instances.*/
    export interface Worker {

        /**The PID of the worker process. */
        readonly pid: number;

        /**Whether the worker is closed. */
        readonly closed: boolean;

        /**Observer events */
        readonly observer: Readonly<WorkerObserver>;

        /**Closes the worker. Triggers a "workerclose" event in all its routers.*/
        close(): void;

        /**Updates the worker settings in runtime. Just a subset of the worker settings can be updated. */
        updateSettings(settings: WorkerUpdateableSettings): Promise<void>;

        /**Creates a new router.*/
        createRouter(options: RouterOptions): Promise<Router>

        /**Emitted when the worker process unexpectedly dies. This should never happens (if it happens, it's a bug).*/
        on(eventType: "died", handler: () => void): void;
    }

    export interface WorkerObserver extends EventEmitter {
        
        /**Emitted when the worker is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): this;
        
        /**Emitted when a new router is created.*/
        on(eventType: "newrouter", handler: (router: Router) => void): this;
    }

    /**Feature codecs such as RTX MUST NOT be placed into the mediaCodecs list. If preferredPayloadType is given in a RtpCodecCapability (although it's unnecessary) it's extremely recommended to use a value in the 96-127 range. */
    export interface RouterOptions {
        /**Router media codecs*/
        mediaCodecs?: RtpCodecCapability[];
    }

    /**A router enables injection, selection and forwarding of media streams through Transport instances created on it. Developers may think of a mediasoup router as if it were a "multi-party conference room", although mediasoup is much more low level than that and doesn't constrain itself to specific high level use cases (for instance, a "multi-party conference room" could involve various mediasoup routers, even in different physicals hosts).*/
    export interface Router {

        /**Router identifier.*/
        readonly id: string;

        /**Whether the router is closed.*/
        readonly closed: boolean;

        /**An Object with the RTP capabilities of the router. These capabilities are typically needed by mediasoup clients to compute their sending RTP parameters. Check the RTP Parameters and Capabilities section for more details.*/
        readonly rtpCapabilities: Readonly<RtpCapabilities>;

        /**Observer events */
        readonly observer: Readonly<RouterObserver>;

        /**Closes the router. Triggers a "routerclose" event in all its transports and also "routerclose" event in all its RTP observers.*/
        close(): void;

        /**Creates a new WebRTC transport.*/
        createWebRtcTransport<AppDataT extends Record<any,any>>(options: WebRtcTransportOptions<AppDataT>): Promise<WebRtcTransport<AppDataT>>

        /**Creates a new plain RTP transport.*/
        createPlainRtpTransport<AppDataT extends Record<any,any>>(options: PlainRtpTransportOptions<AppDataT>): Promise<PlainRtpTransport<AppDataT>>

        /**Creates a new pipe transport.*/
        createPipeTransport<AppDataT extends Record<any,any>>(options: PipeTransportOptions<AppDataT>): Promise<PipeTransport<AppDataT>>

        /**Pipes the given media or data producer into another router in the same host. It creates an underlying PipeTransport (if not previously created) that interconnects both routers.<br>
        This is specially useful to expand broadcasting capabilities (one to many) by interconnecting different routers that run in separate workers (so in different CPU cores).
        Only one of producerId and dataProducerId must be provided.
        SCTP agruments will only apply the first time the underlying transports are created.
        //TODO Document parameters
        */
        pipeToRouter(params: {
            producerId?: string,
            dataProducerId?: string,
            router: Router,
            listenIp?: string,
            enableSctp?: boolean,
            numSctpStreams?: TransportNumSctpStreams
        }):
            Promise<{
                pipeConsumer: Consumer;
                pipeProducer: Producer
            }>

        /**Creates a new audio level observer.*/
        createAudioLevelObserver(options: AudioLevelObserverOptions): Promise<AudioLevelObserver>;

        /**Whether the given RTP capabilities are valid to consume the given producer. 
        //TODO: Document parameters
        */
        canConsume(params: {
            producerId: string;
            rtpCapabilities: RtpCapabilities
        }): boolean;

        /**Emitted when the worker this router belongs to is closed for whatever reason. The router itself is also closed. A "routerclose" event is triggered in all its transports and a "routerclose" event is triggered in all its RTP observers.*/
        on(eventType: "workerclose", handler: () => void): void;
    }

    export interface RouterObserver extends EventEmitter {

        /**Emitted when the router is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): this;

        /**Emitted when a new transport is created.*/
        on(eventType: "newtransport", handler: (transport: Transport) => void): this;
    }

    export interface TransportListenIp {
        
        /**Listening IPv4 or IPv6.*/
        ip: string;
        
        /**Announced IPv4 or IPv6 (useful when running mediasoup behind NAT with private IP).*/
        announcedIp?: string;
    }

    /**Both remoteIp and remotePort are unset until the media address of the remote endpoint is known, which happens after calling transport.connect() in PlainRtpTransport and PipeTransport, or via dynamic detection as it happens in WebRtcTransport (in which the remote media address is detected by ICE means), or in PlainRtpTransport (when using comedia mode).*/
    export interface TransportTuple {

        /**Local IP address.*/
        localIP: string;

        /**Local port*/
        localPort: number;

        /**Remote IP address*/
        remoteIp?: string;

        /**Remote port.*/
        remotePort?: number;

        /**Protocol*/
        protocol: "udp" | "tcp"
    }

    export interface TransportSctpParameters {

        /**Must always equal 5000.*/
        port: number;

        /**Initially requested number of outgoing SCTP streams.*/
        OS: number

        /**Maximum number of incoming SCTP streams.*/
        MIS: number;

        /**Maximum allowed size for SCTP messages.*/
        maxMessageSize: number;
    }

    /**Both OS and MIS are part of the SCTP INIT+ACK handshake. OS refers to the initial number of outgoing SCTP streams that the server side transport creates (to be used by DataConsumers), while MIS refers to the maximum number of incoming SCTP streams that the server side transport can receive (to be used by DataProducers). So, if the server side transport will just be used to create data producers (but no data consumers), OS can be low (~1). However, if data consumers are desired on the server side transport, OS must have a proper value and such a proper value depends on whether the remote endpoint supports  SCTP_ADD_STREAMS extension or not.<br>
    libwebrtc (Chrome, Safari, etc) does not enable SCTP_ADD_STREAMS so, if data consumers are required,  OS should be 1024 (the maximum number of DataChannels that libwebrtc enables).<br>
    Firefox does enable SCTP_ADD_STREAMS so, if data consumers are required, OS can be lower (16 for instance). The mediasoup transport will allocate and announce more outgoing SCTM streams when needed.<br>
    mediasoup-client provides specific per browser/version OS and MIS values via the device.sctpCapabilities getter.<br> */
    export interface TransportNumSctpStreams {
        
        /**Initially requested number of outgoing SCTP streams (from 1 to 65535). Default 1024.*/
        OS: number;
        
        /**Maximum number of incoming SCTP streams (from 1 to 65535). Default 1024.*/
        MIS: number;
    }

    type SctpState = 'new' | 'connecting' | 'connected' | 'failed' | 'closed';

    /**A transport connects an endpoint with a mediasoup router and enables transmission of media in both directions by means of Producer and Consumer instances created on it.<br>

    mediasoup implements the following transport classes:<br>
    * WebRtcTransport<br>
    * PlainRtpTransport<br>
    * PipeTransport<br>
    */
    export interface Transport<AppDataT extends Record<any,any> = Record<any,any>> {
        
        /**Transport identifier.*/
        readonly id: string;
        
        /**Whether the transport is closed.*/
        readonly closed: boolean;
        
        /**Custom data Object provided by the application in the transport factory method. The app can modify its content at any time.*/
        readonly appData: AppDataT;
        
        /**Transport observer*/
        readonly observer: Readonly<TransportObserver>;

        /**Closes the transport. Triggers a "transportclose" event in all its producers and also "transportclose" event in all its consumers.*/
        close(): void;

        /**Returns current RTC statistics of the transport. Each transport class produces a different set of statistics.*/
        getStats(): Promise<any[]>

        /**Instructs the transport to receive audio or video RTP (or SRTP depending on the transport class). This is the way to inject media into mediasoup.*/
        produce<AppDataT extends Record<any,any>>(options: ProducerOptions<AppDataT>): Promise<Producer<AppDataT>>;

        /**Instructs the transport to send audio or video RTP (or SRTP depending on the transport class). This is the way to extract media from mediasoup.*/
        consume<AppDataT extends Record<any,any>>(options: ConsumerOptions<AppDataT>): Promise<Consumer<AppDataT>>;

        /**Instructs the transport to receive data via SCTP. This is the way to inject data into mediasoup.*/
        produceData<AppDataT extends Record<any,any>>(options: DataProducerOptions<AppDataT>): Promise<DataProducer<AppDataT>>

        /**Instructs the transport to send data via SCTP. This is the way to extract data from mediasoup.*/
        consumeData<AppDataT extends Record<any,any>>(options: DataConsumerOptions<AppDataT>): Promise<DataConsumer<AppDataT>>

        /**Emitted when the router this transport belongs to is closed for whatever reason. The transport itself is also closed. A "transportclose" event is triggered in all its producers and a "transportclose" event is triggered in all its consumers.*/
        on(eventType: "routerclose", handler: () => void): void;
    }

    export interface TransportObserver extends EventEmitter {
       
        /**Emitted when the transport is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): this;
       
        /**Emitted when a new producer is created.*/
        on(eventType: "newproducer", handler: (producer: Producer) => void): this;
       
        /**Emitted when a new consumer is created.*/
        on(eventType: "newconsumer", handler: (consumer: Consumer) => void): this;
       
        /**Emitted when a new data producer is created.*/
        on(eventType: "newdataproducer", handler: (dataProducer: DataProducer) => void): this;
       
        /**Emitted when a new data consumer is created.*/
        on(eventType: "newdataconsumer", handler: (dataConsumer: DataConsumer) => void): this;
    }

    /**Both initialAvailableOutgoingBitrate and minimumAvailableOutgoingBitrate are just applied when the consumer endpoint supports REMB or Transport-CC.<br>
    If given, minimumAvailableOutgoingBitrate must be higher or equal than initialAvailableOutgoingBitrate.*/
    export interface WebRtcTransportOptions<AppDataT extends Record<any,any> = Record<any,any>> {
        
        /**Listening IP address or addresses in order of preference /**(first one is the preferred one).*/
        listenIps: TransportListenIp[] | TransportListenIp | string;
        
        /**Listen in UDP. Default true.*/
        enableUdp?: boolean;
        
        /**Listen in TCP. Default false.*/
        enableTcp?: boolean;
        
        /**Listen in UDP. Default false.*/
        preferUdp?: boolean;
        
        /**Listen in TCP. Default false.*/
        preferTcp?: boolean;
        
        /**Initial available outgoing bitrate (in bps). Default 600000*/
        initialAvailableOutgoingBitrate?: number
        
        /**Minimum available outgoing bitrate (in bps) to apply when the consumer endpoint reports less than this value. Use it with caution. Default 300000.*/
        minimumAvailableOutgoingBitrate?: number;
        
        /**Create a SCTP association. Default false*/
        enableSctp?: boolean;
        
        /**SCTP streams number.*/
        numSctpStreams?: TransportNumSctpStreams;
        
        /**Maximum size of data that can be passed to DataProducer's send() method. Default 262144*/
        maxSctpMessageSize?: number;
        
        /**Custom application data.*/
        appData?: AppDataT;
    }

    export interface IceParameters {
        
        /**ICE username fragment*/
        usernameFragment?: string;
        
        /**ICE password.*/
        password?: string;
        
        /**ICE Lite*/
        iceLite: boolean;
    }

    export interface IceCandidate {
        
        /**Unique identifier that allows ICE to correlate candidates that appear on multiple transports.*/
        foundation: string;
        
        /**The assigned priority of the candidate.*/
        priority: number;
        
        /**The IP address of the candidate.*/
        ip: string;
        
        /**The protocol of the candidate ("udp" / "tcp").*/
        protocol: "udp" | "tcp";
        
        /**The port for the candidate.*/
        port: number;
        
        /**The type of candidate (always "host").*/
        type: "host";
        
        /**The type of TCP candidate (always "passive").*/
        tcpType: "passive";
    }

    export interface DtlsParameters {
        
        /**DTLS role. Default "auto" */
        role?: DtlsRole;
        
        /**DTLS fingerprints.*/
        fingerprints: DtlsFingerprints;
    }

    /**Map of DTLS algorithms (as defined in the "Hash function Textual Names" registry initially specified in RFC 4572 Section 8) and their corresponding certificate fingerprint values (in lowercase hex string as expressed utilizing the syntax of "fingerprint" in RFC 4572 Section 5).*/
    export interface DtlsFingerprints {
        
        /**SHA-1 certificate fingerprint.*/
        "sha-1"?: string;
        
        /**SHA-224 certificate fingerprint.*/
        "sha-224"?: string;
        
        /**SHA-256 certificate fingerprint.*/
        "sha-256"?: string;
        
        /**SHA-384 certificate fingerprint.*/
        "sha-384"?: string;
        
        /**SHA-512 certificate fingerprint.*/
        "sha-512"?: string;
    }

    /**
     * “new”: No ICE Binding Requests have been received yet.<br>
     * “connected”:Valid ICE Binding Request have been received, but none with USE-CANDIDATE attribute. Outgoing media is allowed.<br>
     * “completed”: ICE Binding Request with USE_CANDIDATE attribute has been received. Media in both directions is now allowed.<br>
     * “disconnected”: ICE was “connected” or “completed” but it has suddenly failed (this can just happen if the selected tuple has “tcp” protocol).<br>
     * “closed”: ICE state when the transport has been closed.<br>
    */
    export type IceState = "new"
        | "connected"
        | "completed"
        | "disconnected"
        | "closed";

    /** 
     * “auto”: The DTLS role is determined based on the resolved ICE role (the “controlled” role acts as DTLS client, the “controlling” role acts as DTLS server”). Since mediasoup is a ICE Lite implementation it always behaves as ICE “controlled”.
     * “client”: DTLS client role.
     * “server”: DTLS server role.*/
    export type DtlsRole = "auto" | "client" | "server";

    /**
     * “new”: DTLS procedures not yet initiated.<br>
     * “connecting”: DTLS connecting.<br>
     * “connected”: DTLS successfully connected (SRTP keys already extracted).<br>
     * “failed”: DTLS connection failed.<br>
     * “closed”: DTLS state when the transport has been closed.<br>
     */
    export type DtlsState = "new" | "connecting" | "connected" | "failed" | "closed";

    /**A WebRTC transport represents a network path negotiated by both, a WebRTC endpoint and mediasoup, via ICE and DTLS procedures. A WebRTC transport may be used to receive media, to send media or to both receive and send. There is no limitation in mediasoup. However, due to their design, mediasoup-client and libmediasoupclient require separate WebRTC transports for sending and receiving.<br>
    The WebRTC transport implementation of mediasoup is ICE Lite, meaning that it does not initiate ICE connections but expects ICE Binding Requests from endpoints.*/
    export interface WebRtcTransport<AppDataT extends Record<any,any> = Record<any,any>> extends Transport<AppDataT> {

        /**Local ICE role. Due to the mediasoup ICE Lite design, this is always “controlled”. */
        readonly iceRole: "controlled";

        /**Local ICE parameters. */
        readonly iceParameters: Readonly<IceParameters>;

        /**Local ICE candidates. */
        readonly iceCandidates: ReadonlyArray<IceCandidate[]>;

        /**Current ICE state.*/
        readonly iceState: Readonly<IceState>;

        /**The selected transport tuple if ICE is in “connected” or “completed” state. It is undefined if ICE is not established (no working candidate pair was found).*/
        readonly iceSelectedTuple: Readonly<TransportTuple>;

        /**Local DTLS parameters.*/
        readonly dtlsParameters: Readonly<DtlsParameters>;

        /**Current DTLS state.*/
        readonly dtlsState: Readonly<DtlsState>;

        /**The remote certificate in PEM format. It is set once the DTLS state becomes “connected”. The application may want to inspect the remote certificate for authorization purposes by using some certificates utility such as the Node pem module.*/
        readonly dtlsRemoteCert: string;

        /**Local SCTP parameters.*/
        readonly sctpParameters: string;

        /**Current SCTP state.*/
        readonly sctpState: Readonly<SctpState>;

        /**WebRtcTransportTransport observer*/
        readonly observer: Readonly<WebRtcTransportObserver>;

        /**Provides the WebRTC transport with the endpoint parameters. */
        connect(options: {dtlsParameters: DtlsParameters }): Promise<void>;

        /**Set maximum incoming bitrate for media streams sent by the remote endpoint over this WebRTC transport. This method just works when REMB is available in the remote sender.*/
        setMaxIncomingBitrate(bitrate: number): Promise<void>;

        /**Restarts the ICE layer by generating new local ICE parameters that must be signaled to the remote endpoint.*/
        restartIce(): Promise<IceParameters>

        //--- Copy from Transport ---

        /**Emitted when the router this transport belongs to is closed for whatever reason. The transport itself is also closed. A "transportclose" event is triggered in all its producers and a "transportclose" event is triggered in all its consumers.*/
        on(eventType: "routerclose", handler: () => void): void;

        //--- End copy from Transport ---

        /**Emitted when the transport ICE state changes.*/
        on(eventType: "icestatechange", handler: (iceState: IceState) => void): void;

        /**Emitted after ICE state becomes “completed” and when the ICE selected tuple changes.*/
        on(eventType: "iceselectedtuplechange", handler: (iceSelectedTuple: TransportTuple) => void): void;

        /**Emitted when the transport DTLS state changes.*/
        on(eventType: "dtlsstatechange", handler: (dtlsState: DtlsState) => void): void;

        /**Emitted when the transport SCTP state changes.*/
        on(eventType: "sctpstatechange", handler: (sctpState: SctpState) => void): void;
       
    }

    export interface WebRtcTransportObserver extends TransportObserver {

        //--- Copy from TransportObserver ---

        /**Emitted when the transport is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): this;
        
        /**Emitted when a new producer is created.*/
        on(eventType: "newproducer", handler: (producer: Producer) => void): this;
        
        /**Emitted when a new consumer is created.*/
        on(eventType: "newconsumer", handler: (consumer: Consumer) => void): this;
        
        /**Emitted when a new data producer is created.*/
        on(eventType: "newdataproducer", handler: (dataProducer: DataProducer) => void): this;
        
        /**Emitted when a new data consumer is created.*/
        on(eventType: "newdataconsumer", handler: (dataConsumer: DataConsumer) => void): this;

        //--- End copy from TransportObserver ---
        
        /**Emitted when the transport ICE state changes.*/
        on(eventType: "icestatechange", handler: (iceState: IceState) => void): this;

        /**Emitted after ICE state becomes “completed” and when the ICE selected tuple changes.*/
        on(eventType: "iceselectedtuplechange", handler: (iceSelectedTuple: TransportTuple) => void): this;

        /**Emitted when the transport DTLS state changes.*/
        on(eventType: "dtlsstatechange", handler: (dtlsState: DtlsState) => void): this;

        /**Emitted when the transport SCTP state changes.*/
        on(eventType: "sctpstatechange", handler: (sctpState: SctpState) => void): this;
    }

    /**Note that comedia mode just makes sense when the remote endpoint is gonna produce RTP on this plain RTP transport. Otherwise, if the remote endpoint does not send any RTP packet to mediasoup, there is no way to detect its remote RTP IP and port, so the endpoint won't receive any packet from mediasoup.<br>
    In other words, do not use comedia mode if the remote endpoint is not going to produce RTP but just consume it. In those cases, do not set comedia flag and call connect() with the IP and port(s) of the remote endpoint.<br>
    When multiSource is set, the producer endpoint won't receive any RTCP packet from mediasoup. Try to avoid multiSource if possible. In case of video, if the producer does not send periodic video key frames, consumers will have problems to render the video (since RTCP PLI or FIR cannot be delivered to the producer if multiSource is set).<br>
    */
    export interface PlainRtpTransportOptions<AppDataT extends Record<any,any> = Record<any,any>> {

        /**Listening IP address. */
        listenIp: TransportListenIp | string;

        /**Use RTCP-mux (RTP and RTCP in the same port). Default true*/
        rtcpMux?: boolean;

        /**Whether remote IP:port should be auto-detected based on first RTP/RTCP packet received. If enabled, connect() method must not be called. This option is ignored if multiSource is set. Default false*/
        comedia?: boolean;

        /**Whether RTP/RTCP from different remote IPs:ports is allowed. If set, the transport will just be valid for receiving media (consume() cannot be called on it) and connect() must not be called. Default false*/
        multiSource?: boolean;

        /**Create a SCTP association. Default false*/
        enableSctp?: boolean;

        /**SCTP streams number.Default */
        numSctpStreams?: TransportNumSctpStreams;

        /**Maximum size of data that can be passed to DataProducer's send() method. Default 262144*/maxSctpMessageSize?: number;

        /**Custom application data.Default{ }*/
        readonly appData?: AppDataT;
    }

    /**A plain RTP transport represents a network path through which plain RTP and RTCP is transmitted.*/
    export interface PlainRtpTransport<AppDataT extends Record<any,any> = Record<any,any>> extends Transport<AppDataT> {

        /**The transport tuple. If RTCP-mux is enabled (rtcpMux is set), this tuple refers to both RTP and RTCP. */
        readonly tuple: Readonly<TransportTuple>;

        /**The transport tuple for RTCP. If RTCP-mux is enabled (rtcpMux is set), its value is undefined. */
        readonly rtcpTuple: Readonly<TransportTuple>;

        /**Local SCTP parameters. */
        readonly sctpParameters: Readonly<TransportSctpParameters>;

        /**Current SCTP state. */
        readonly sctpState: Readonly<SctpState>;

        readonly observer: Readonly<PlainRtpTransportObserver>;

        /**Provides the plain RTP transport with the endpoint parameters. It must not be called when comedia mode is enabled (in this case the remote media address will be detected dynamically) or when multiSource is set. <pr>
         * ip: string: Remote IPv4 or IPv6.
         * port: number: Remote port.
         * rtcpPort: number: Remote RTCP port (required if RTCP-mux is not enabled).
        */
        connect(param: { ip: string; port: number; rtcpPort?: number }): Promise<void>;

        /**Emitted when the transport SCTP state changes.*/
        on(eventType: "sctpstatechange", handler: (sctpState: SctpState) => void): void;

        //--- Copy from Transport

        /**Emitted when the router this transport belongs to is closed for whatever reason. The transport itself is also closed. A "transportclose" event is triggered in all its producers and a "transportclose" event is triggered in all its consumers.*/
        on(eventType: "routerclose", handler: () => void): void;

        //--- End copy from Transport
    }

    export interface PlainRtpTransportObserver extends TransportObserver {

        //--- Copy from TransportObserver ---

        /**Emitted when the transport is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): this;
        
        /**Emitted when a new producer is created.*/
        on(eventType: "newproducer", handler: (producer: Producer) => void): this;
        
        /**Emitted when a new consumer is created.*/
        on(eventType: "newconsumer", handler: (consumer: Consumer) => void): this;
        
        /**Emitted when a new data producer is created.*/
        on(eventType: "newdataproducer", handler: (dataProducer: DataProducer) => void): this;
        
        /**Emitted when a new data consumer is created.*/
        on(eventType: "newdataconsumer", handler: (dataConsumer: DataConsumer) => void): this;

        //--- End copy from TransportObserver ---
        
        /**Emitted when the transport SCTP state changes.*/
        on(eventType: "sctpstatechange", handler: (sctpState: SctpState) => void): this;
    }

    export interface PipeTransportOptions<AppDataT extends Record<any,any> = Record<any,any>> {

        /** Listening IP address.*/
        listenIp: TransportListenIp | string;

        /** Create a SCTP association. Default false*/
        enableSctp?: boolean;

        /** SCTP streams number. Default false*/
        numSctpStreams?: TransportNumSctpStreams;

        /** Maximum size of data that can be passed to DataProducer's send() method. Default 1073741823*/
        maxSctpMessageSize?: number;

        /** Custom application data.**/
        readonly appData?: AppDataT;
    }

    /**A pipe transport represents a network path through which plain RTP and RTCP is transmitted. Pipe transports are intented to intercommunicate two Router instances collocated on the same host or on separate hosts. When calling consume() on a pipe transport, all RTP streams of the Producer are transmitted verbatim (in contrast to what happens in WebRtcTransport and PlainRtpTransport in which a single and continuos RTP stream is sent to the consuming endpoint).*/
    export interface PipeTransport<AppDataT extends Record<any,any> = Record<any,any>> extends Transport<AppDataT> {

        /**The transport tuple. It refers to both RTP and RTCP since pipe transports use RTCP-mux by design. Once the pipe transport is created, transport.tuple will contain information about its localIp,  localPort and protocol.
        Information about remoteIp and remotePort will be set after calling connect() method.*/
        readonly tuple: Readonly<TransportTuple>;

        /**Local SCTP parameters. */
        readonly sctpParameters: Readonly<TransportSctpParameters>; //TODO: Doc has a typo indicating SctpParameters;

        /**Current SCTP state. */
        readonly sctpState: Readonly<SctpState>;

        readonly observer: Readonly<PipeTransportObserver>;

        /**Provides the pipe RTP transport with the remote parameters.*/
        connect(param: { ip: string; port: number }): Promise<void>;

        /**Emitted when the transport SCTP state changes.*/
        on(eventType: "sctpstatechange", handler: (sctpState: SctpState) => void): void;

        //--- Copy from Transport

        /**Emitted when the router this transport belongs to is closed for whatever reason. The transport itself is also closed. A "transportclose" event is triggered in all its producers and a "transportclose" event is triggered in all its consumers.*/
        on(eventType: "routerclose", handler: () => void): void;

        //--- End copy from Transport
    }

    export interface PipeTransportObserver extends TransportObserver {

        //--- Copy from TransportObserver ---

        /**Emitted when the transport is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): this;
        
        /**Emitted when a new producer is created.*/
        on(eventType: "newproducer", handler: (producer: Producer) => void): this;
        
        /**Emitted when a new consumer is created.*/
        on(eventType: "newconsumer", handler: (consumer: Consumer) => void): this;
        
        /**Emitted when a new data producer is created.*/
        on(eventType: "newdataproducer", handler: (dataProducer: DataProducer) => void): this;
        
        /**Emitted when a new data consumer is created.*/
        on(eventType: "newdataconsumer", handler: (dataConsumer: DataConsumer) => void): this;

        //--- End copy from TransportObserver ---

        /**Emitted when the transport SCTP state changes.*/
        on(eventType: "sctpstatechange", handler: (sctpState: SctpState) => void): this;

    }

    export type MediaKind = "audio" | "video";

    /**Check the RTP Parameters and Capabilities section for more details.*/
    export interface ProducerOptions<AppDataT extends Record<any,any> = Record<any,any>> {
    
        /**Media kind*/
        kind: MediaKind;

        /**RTP parameters defining what the endpoint is sending.*/
        rtpParameters: RtpSendParameters;

        /**Whether the producer must start in paused mode. Default false*/
        paused?: boolean;

        /**Custom application data.*/
        readonly appData?: AppDataT;
    }

    export interface ProducerRtpStreamScore {
    
        /**RTP stream SSRC.*/
        ssrc: number;
    
        /**RTP stream RID value.*/
        rid?: string;
    
        /**RTP stream score (from 0 to 10) representing the transmission quality.*/
        score: number;
    }

    /**As documented in WebRTC Video Processing and Codec Requirements.*/
    export interface ProducerVideoOrientation {

        /**Whether the source is a video camera.*/
        camera: boolean;

        /**Whether the video source is flipped.*/
        flip: boolean;

        /**Rotation degrees (0, 90, 180 or 270).*/
        rotation: number;
    }

    /**ProducerType:
     * "simple": A single RTP stream is received with no spatial/temporal layers.
     * “simulcast”: Two or more RTP streams are received, each of them with one or more temporal layers.
     * “svc”: A single RTP stream is received with spatial/temporal layers. */
    export type ProducerType = "simple" | "simulcast" | "svc";

    export interface Producer<AppDataT extends Record<any,any> = Record<any,any>> {

        /**Producer identifier.*/
        readonly id: string;

        /**Whether the producer is closed.*/
        readonly closed: boolean;

        /**The media kind.*/
        readonly kind: MediaKind;

        /**Producer RTP parameters.*/
        readonly rtpParameters: Readonly<RtpSendParameters>;

        /**The RTC transmission type.*/
        readonly type: Readonly<ProducerType>;

        /**Whether the producer is paused.*/
        readonly paused: boolean;

        /**The score of each RTP stream being received, representing their tranmission quality.*/
        readonly score: ReadonlyArray<ProducerRtpStreamScore[]>;

        /**Custom data Object provided by the application in the producer factory method. The app can modify its content at any time.*/ 
        readonly appData?: AppDataT;

        readonly observer: Readonly<ProducerObserver>;

        /**Closes the producer. Triggers a “producerclose” event in all its associated consumers.*/
        close(): void;

        /**Returns current RTC statistics of the producer.*/
        getStats(): Promise<any[]>

        /**Pauses the producer (no RTP is sent to its associated consumers). Triggers a “producerpause” event in all its associated consumers.*/
        pause(): Promise<void>;

        /**Resumes the producer (RTP is sent again to its associated consumers). Triggers a “producerresume” event in all its associated consumers.*/
        resume(): Promise<void>;

        /**Emitted when the transport this producer belongs to is closed for whatever reason. The producer itself is also closed. A “producerclose” event is triggered in all its associated consumers.*/
        on(eventType: "transportclose", handler: () => void): void;

        /**Emitted when the producer score changes.*/
        on(eventType: "score", handler: (score: ProducerRtpStreamScore[]) => void): void;

        /**Emitted when the video orientation changes. This is just possible if the “urn:3gpp:video-orientation” RTP extension has been negotiated in the producer RTP parameters.*/
        on(eventType: "videoorientationchange", handler: (videoOrientation: ProducerVideoOrientation) => void): void;
    }

    export interface ProducerObserver {

        /**Emitted when the producer is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): void;

        /**Emitted when the producer is paused.*/
        on(eventType: "pause", handler: () => void): void;

        /**Emitted when the producer is resumed.*/
        on(eventType: "resume", handler: () => void): void;

        /**Emitted when the producer score changes.*/
        on(eventType: "score", handler: (score: ProducerRtpStreamScore[]) => void): void;

        /**Emitted when the video orientation changes. This is just possible if the “urn:3gpp:video-orientation” RTP extension has been negotiated in the producer RTP parameters.*/
        on(eventType: "videoorientationchange", handler: (videoOrientation: ProducerVideoOrientation) => void): void;
    }

    export interface ConsumerOptions<AppDataT extends Record<any,any> = Record<any,any>> {
        
        /**The id of the producer to consume.*/
        producerId: string;

        /**RTP capabilities of the consuming endpoint.*/
        rtpCapabilities: RtpCapabilities;

        /**Whether the consumer must start in paused mode. Default false<br>. When creating a video consumer, it's recommended to set paused to true, then transmit the consumer parameters to the consuming endpoint and, once the consuming endpoint has created its local side consumer, unpause the server side consumer using the resume() method. This is an optimization to make it possible for the consuming endpoint to render the video as far as possible. If the server side consumer was created with paused: false, mediasoup will immediately request a key frame to the producer and that key frame may reach the consuming endpoint even before it's ready to consume it, generating “black” video until the device requests a keyframe by itself.*/
        paused?: boolean;

        /**Preferred spatial and temporal layer for simulcast or SVC media sources. If unset, the highest ones are selected. */
        preferredLayers?: ConsumerLayers;

        /**Custom application data.*/
        readonly appData?: AppDataT;
    }

    export interface ConsumerLayers {
        
        /**The spatial layer index (from 0 to N)*/
        spatialLayer: number;

        /**The temporal layer index (from 0 to N)*/
        temporalLayer?: number;
    }

    export interface ConsumerRtpStreamScore {
        
        /**Score of the RTP stream in the consumer (from 0 to 10) representing its transmission quality.*/
        score: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;

        /**Score of the currently selected RTP stream in the associated producer (from 0 to 10) representing its transmission quality*/
        producerScore:  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
    }

    /**ConsumerType
    * “simple”: A single RTP stream is sent with no spatial/temporal layers.
    * “simulcast”: Two or more RTP streams are sent, each of them with one or more temporal layers.
    * “svc”: A single RTP stream is sent with spatial/temporal layers.
    * “pipe”: Special type for consumers created on a PipeTransport. */
    export type ConsumerType = "simple" | "simulcast" | "svc" | "pipe";

    export interface Consumer<AppDataT extends Record<any,any> = Record<any,any>> {
        
        /**Consumer identifier.*/
        readonly id: string;

        /**The associated producer identifier.*/
        readonly producerId: string;

        /**Whether the consumer is closed.*/
        readonly closed: boolean;

        /**The media kind (“audio” or “video”).*/
        readonly kind: MediaKind;

        /**Consumer RTP parameters. */
        readonly rtpParameters: Readonly<RtpReceiveParameters>;

        /**The RTC transmission type.*/
        readonly type: Readonly<ConsumerType>;

        /**Whether the consumer is paused. It does not take into account whether the associated producer is paused. */
        readonly paused: boolean;

        /**Whether the associated producer is paused.*/
        readonly producerPaused: boolean;

        /**The score of the RTP stream being sent, representing its tranmission quality.*/
        readonly score: Readonly<ConsumerRtpStreamScore>;

        /**Current spatial and temporal layers (for simulcast and SVC consumers). It's null if no layers are being sent to the consuming endpoint.*/
        readonly currentLayers: Readonly<ConsumerLayers>;

        /**Custom data Object provided by the application in the consumer factory method. The app can modify its content at any time.*/
        readonly appData: AppDataT;

        readonly observer: ConsumerObserver;

        /**Closes the consumer.*/
        close(): void;

        /**Returns current RTC statistics of the consumer.*/
        getStats(): Promise<any[]>

        /**Pauses the consumer (no RTP is sent to the consuming endpoint).*/
        pause(): Promise<void>;

        /**Resumes the consumer (RTP is sent again to the consuming endpoint).*/
        resume(): Promise<void>;

        /**Sets the preferred (highest) spatial and temporal layers to be sent to the consuming endpoint. Just valid for simulcast and SVC consumers. (if unset, the highest one is chosen).*/
        setPreferredLayers(preferredLayers?: ConsumerLayers): Promise<void>

        /**Request a key frame to the associated producer. Just valid for video consumers.*/
        requestKeyFrame(): Promise<void>

        /**Emitted when the transport this consumer belongs to is closed for whatever reason. The consumer itself is also closed.*/
        on(eventType: "transportclose", handler: () => void): void;

        /**Emitted when the associated producer is closed for whatever reason. The consumer itself is also closed.*/
        on(eventType: "producerclose", handler: () => void): void;

        /**Emitted when the associated producer is paused.*/
        on(eventType: "producerpause", handler: () => void): void;

        /**Emitted when the associated producer is resumed.*/
        on(eventType: "producerresume", handler: () => void): void;

        /**Emitted when the consumer score changes.*/
        on(eventType: "score", handler: (score: ConsumerRtpStreamScore) => void): void;

        /**Emitted when the spatial/temporal layers being sent to the endpoint change. Just for simulcast or SVC consumers. Current spatial and temporal layers (or null if there are no current layers).
         * 
         * This event is emitted under various circumstances in SVC or simulcast consumers (assuming the consumer endpoints supports BWE via REMB or Transport-CC):

            * When the consumer (or its associated producer) is paused.
            * When all the RTP streams of the associated producer become inactive (no RTP received for a while).
            * When the available bitrate of the BWE makes the consumer upgrade or downgrade the spatial and/or temporal layers.
            * When there is no available bitrate for this consumer (even for the lowest layers) so the event fires with  null as argument.
        The Node.js application can detect the latter (consumer deactivated due to not enough bandwidth) by checking if both consumer.paused and consumer.producerPaused are falsy after the consumer has emitted this event with null as argument.*/
        on(eventType: "layerschange", handler: (layers?: ConsumerLayers) => void): void;
    }

    export interface ConsumerObserver {

        /**Emitted when the consumer is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): void;

        /**Emitted when the consumer or its associated producer is paused and, as result, the consumer becomes paused.*/
        on(eventType: "pause", handler: () => void): void;

        /**Emitted when the consumer or its associated producer is resumed and, as result, the consumer is no longer paused.*/
        on(eventType: "resume", handler: () => void): void;

        /**Same as the score event.*/
        on(eventType: "score", handler: (score: ConsumerRtpStreamScore) => void): void;

        /**Same as the layerschange event.*/
        on(eventType: "layerschange", handler: (layers?: ConsumerLayers) => void): void;

    }

    export interface DataProducerOptions<AppDataT extends Record<any,any> = Record<any,any>> {
        
        /**	SCTP parameters defining how the endpoint is sending the data.*/
        sctpStreamParameters: SctpStreamParameters;

        /**A label which can be used to distinguish this DataChannel from others.*/
        label?: string;

        /**Name of the sub-protocol used by this DataChannel.*/
        protocol?: string;

        /**Custom application data.*/
        appData: AppDataT;
    }

    /**A data producer represents a SCTP data source being injected into a mediasoup router. It's created on top of a transport that defines how the data messages are carried.*/
    export interface DataProducer<AppDataT extends Record<any,any> = Record<any,any>> {

        /**Data producer identifier.*/
        readonly id: string;

        /**Whether the data producer is closed.*/
        readonly closed: boolean;

        /**The SCTP stream parameters.*/
        readonly sctpStreamParameters: Readonly<SctpStreamParameters>;

        /**The data producer label.*/
        readonly label: string;

        /**The data producer sub-protocol.*/
        readonly protocol: string;

        /**Custom data Object provided by the application in the producer factory method. The app can modify its content at any time.*/
        readonly appData?: AppDataT;

        readonly observer: DataProducerObserver;

        /**Closes the producer. Triggers a “dataproducerclose” event in all its associated consumers.*/
        close(): void;

        /**Returns current SCTP statistics of the producer.*/
        getStats(): Promise<any>;

        /**Emitted when the transport this data producer belongs to is closed for whatever reason. The producer itself is also closed. A “dataproducerclose” event is triggered in all its associated consumers.*/
        on(eventType: "transportclose", handler: () => void): void;
    }

    export interface DataProducerObserver {
        /**Emitted when the producer is closed for whatever reason.*/
        on(eventType: "close", handler: () => void): void;
    }

    export interface DataConsumerOptions<AppDataT extends Record<any,any> = Record<any,any>> {
        /**The id of the data producer to consume.*/
        producerId: string;

        /**Custom application data.*/
        readonly appData?: AppDataT;
    }

    /**A data consumer represents a SCTP data source being forwarded from a mediasoup router to an endpoint. It's created on top of a transport that defines how the data messages are carried.*/
    export interface DataConsumer<AppDataT extends Record<any,any> = Record<any,any>> {

        /**Data consumer identifier.*/
        readonly id: string;

        /**The associated data producer identifier.*/
        readonly dataProducerId: string;

        /**Whether the data consumer is closed. */
        readonly closed: boolean;

        /**The SCTP stream parameters.*/
        readonly sctpStreamParameters: Readonly<SctpStreamParameters>;

        /**The data producer label.*/
        readonly label: string;

        /**The data producer sub-protocol.*/
        readonly protocol: string;

        /**Custom data Object provided by the application in the data consumer factory method. The app can modify its content at any time.*/
        readonly appData?: AppDataT;

        readonly observer: DataConsumerObserver;

        /**Closes the data consumer.*/
        close(): void;

        /**Returns current SCTP statistics of the data consumer.*/
        getStats(): Promise<any>;

        /**Emitted when the transport this data consumer belongs to is closed for whatever reason. The data consumer itself is also closed.*/
        on(eventType: "transportclose", handler: () => void): void;

        /**Emitted when the associated data producer is closed for whatever reason. The data consumer itself is also closed.*/
        on(eventType: "dataproducerclose", handler: () => void): void;
    }

    export interface DataConsumerObserver {
        on(eventType: "close", handler: () => void): void;
    }

    /**An RTP observer inspects the media received by a set of selected producers. mediasoup implements the following RTP observer classes: AudioLevelObserver.*/
    export interface RtpObserver {

        /**RTP observer identifier.*/
        readonly id: string;

        /**Whether the RTP observer is closed.*/
        readonly closed: boolean;

        /**Whether the RTP observer is paused.*/
        readonly paused: boolean;

        /**Closes the RTP observer.*/
        close(): void;

        /**Pauses the RTP observer. No RTP is inspected until resume() is called.*/
        pause(): Promise<void>;

        /**Resumes the RTP observer. RTP is inspected again.*/
        resume(): Promise<void>;

        /**Provides the RTP observer with a new producer to monitor.*/
        addProducer(producer: Producer): Promise<void>;

        /**Removes the given producer from the RTP observer.*/
        removeProducer(producer: Producer): Promise<void>;

        /**Emitted when the router this RTP observer belongs to is closed for whatever reason. The RTP observer itself is also closed.*/
        on(eventType: "routerclose", handler: () => void): void;
    }

    /**An audio level observer monitors the volume of the selected audio producers. It just handles audio producers (if addProducer() is called with a video producer it will fail).*/
    export interface AudioLevelObserver extends RtpObserver {

        //--- Start copy from RtpObserver to circunvent limitation in TypeScript compiler (see https://github.com/Microsoft/TypeScript/issues/10229)

        /**Emitted when the router this RTP observer belongs to is closed for whatever reason. The RTP observer itself is also closed.*/
        on(eventType: "routerclose", handler: () => void): void;

        //--- End copy ----

        on(eventType: "volumes", handler: (volumes: AudioLevelObserverVolume[]) => void): void;
    }

    export interface AudioLevelObserverOptions {

        /**Maximum number of entries in the “volumes” event. Default 1*/
        maxEntries?: number;

        /**Minimum average volume (in dBvo from -127 to 0) for entries in the “volumes” event.	Default -80*/
        threshold?: number;

        /**	Interval in ms for checking audio volumes. Default 1000*/
        interval?: number;
    }

    export interface AudioLevelObserverVolume {

        /**The audio producer instance.*/
        producer: Producer;

        /**The average volume (in dBvo from -127 to 0) of the audio producer in the last interval.*/
        volume: number;
    }

    /**SCTP stream parameters describe the reliability of a certain SCTP stream. 
     * If ordered is true then maxPacketLifeTime and maxRetransmits must be false.
     * If ordered if false, only one of maxPacketLifeTime or maxRetransmits can be true.
    */
    export interface SctpStreamParameters {

        /**Whether data messages must be received in order. if true the messages will be sent reliably. Default true */
        ordered?: boolean;

        /**When ordered is false indicates the time (in milliseconds) after which a SCTP packet will stop being retransmitted.*/
        maxPacketLifeTime?: number;

        /**When ordered is false indicates the maximum number of times a packet will be retransmitted.*/
        maxRetransmits: number;

    }

    export interface RtpParameters {
        
        /**The MID RTP extension value as defined in the BUNDLE specification.*/
        mid?: string;

        /**Media and RTX codecs in use.*/
        codecs: RtpCodecParameters[];

        /**RTP header extensions in use.*/
        headerExtensions?: RtpHeaderExtensionParameters[];

        /**Transmitted RTP streams and their settings.*/
        encodings: RtpEncodingParameters[];

        /**	Parameters used for RTCP.*/
        rtcp: RtcpParameters;
    }

    /**The RTP send parameters describe a media stream received by mediasoup from an endpoint through its corresponding mediasoup Producer.

    * These parameters may include a mid value that the mediasoup transport will use to match received RTP packets based on their MID RTP extension value.

    * mediasoup allows RTP send parameters with a single encoding and with multiple encodings (simulcast). In the latter case, each entry in the encodings array must include a ssrc field or a rid field (the RID RTP extension value).

    Check the Simulcast and SVC sections for more information.*/
    export interface RtpSendParameters extends RtpParameters { }

    /** The RTP receive parameters describe a media stream as sent by mediasoup to an endpoint through its corresponding mediasoup Consumer.

    * The mid value is unset (mediasoup does not include the MID RTP extension into RTP packets being sent to endpoints).
    * There is a single entry in the encodings array (even if the corresponding producer uses simulcast). The consumer sends a single and continuous RTP stream to the endpoint and spatial/temporal layer selection is possible via consumer.setPreferredLayers().
    * As an exception, previous bullet is not true when consuming a stream over a PipeTransport, in which all RTP streams from the associated producer are forwarded verbatim through the consumer.
    * The RTP receive parameters will always have their ssrc values randomly generated for all of its  encodings (and optional rtx: { ssrc: XXXX } if the endpoint supports RTX), regardless of the original RTP send parameters in the associated producer. This applies even if the producer's encodings have rid set.*/
    export interface RtpReceiveParameters extends RtpParameters { }

    /**The RTP capabilities define what mediasoup or an endpoint can receive at media level.*/
    export interface RtpCapabilities {
        /**	Supported media and RTX codecs.*/
        codecs: RtpCodecCapability[];
        
        /**Supported RTP header extensions.*/
        headerExtensions?: RtpHeaderExtension[];
    }

    /**Provides information on codec settings within the RTP parameters. The list of media codecs supported by mediasoup and their settings is defined in the supportedRtpCapabilities.js file.*/
    export interface RtpCodecParameters {

        /**The codec MIME media type/subtype (e.g. “audio/opus”, “video/VP8”).*/
        mimeType: string;

        /**The value that goes in the RTP Payload Type Field. Must be unique.*/
        payloadType: number;
        
        /**Codec clock rate expressed in Hertz.	*/
        clockRate: number;

        /**The number of channels supported (e.g. two for stereo). Just for audio. Default 1.*/
        channels?: number;

        /**Codec-specific parameters available for signaling. Some parameters (such as “packetization-mode” and “profile-level-id” in H264 or “profile-id” in VP9) are critical for codec matching.*/
        parameters?: any;

        /**Transport layer and codec-specific feedback messages for this codec.	Default	[] */
        rtcpFeedback?: RtcpFeedback[];
    }

    /**Provides information on RTCP feedback messages for a specific codec. Those messages can be transport layer feedback messages or codec-specific feedback messages. The list of RTCP feedbacks supported by mediasoup is defined in the supportedRtpCapabilities.js file. */
    export interface RtcpFeedback {
        /**RTCP feedback type.*/
        type: string; 

        /**RTCP feedback parameter.*/
        parameter: string;
    }

    /**Provides information relating to an encoding, which represents a media RTP stream and its associated RTX stream (if any).*/
    export interface RtpEncodingParameters {
        
        /** The media SSRC.*/
        ssrc?: number;
        
        /**The RID RTP extension value. Must be unique.*/
        rid?:string;

        /**RTX stream information. It must contain a numeric ssrc field indicating the RTX SSRC.*/
        rtx?: any;

        /**It indicates whether discontinuous RTP transmission will be used. Useful for audio (if the codec supports it) and for video screen sharing (when static content is being transmitted, this option disables the RTP inactivity checks in mediasoup). Default false */
        dtx?: boolean;

        /**Number of spatial and temporal layers in the RTP stream (e.g. “L1T3”). See webrtc-svc.*/
        scalabilityMode?: string;
    }

    /**Defines a RTP header extension within the RTP parameters. The list of RTP header extensions supported by mediasoup is defined in the supportedRtpCapabilities.js file.
     * mediasoup does not currently support encrypted RTP header     extensions.
     * No parameters are currently considered. 
    */
    export interface RtpHeaderExtensionParameters {

        /**The URI of the RTP header extension, as defined in RFC 5285.*/
        uri: string;
        
        /**The numeric identifier that goes in the RTP packet. Must be unique.*/
        id: number;

        /**	If true, the value in the header is encrypted as per RFC 6904. Default false*/
        encrypt?: boolean;

        /**Configuration parameters for the header extension.*/
        parameters?: any; 
    }

    /**Provides information on RTCP settings within the RTP parameters. 
     * If no cname is given in a producer's RTP parameters, the mediasoup transport will choose a random one that will be used into RTCP SDES messages sent to all its associated consumers.
     * mediasoup assumes reducedSize to always be true.*/
    export interface RtcpParameters {

        /**	The Canonical Name (CNAME) used by RTCP (e.g. in SDES messages).*/
        cname?: string;

        /**Whether reduced size RTCP RFC 5506 is configured (if true) or compound RTCP as specified in RFC 3550 (if false) .Default true */
        reducedSize: boolean;
    }

    /**Provides information on the capabilities of a codec within the RTP capabilities. The list of media codecs supported by mediasoup and their settings is defined in the supportedRtpCapabilities.js file.
    
    Exactly one RtpCodecCapability will be present for each supported combination of parameters that requires a distinct value of preferredPayloadType. For example:
    
    Multiple H264 codecs, each with their own distinct “packetization-mode” and “profile-level-id” values.
    Multiple VP9 codecs, each with their own distinct “profile-id” value. 
    
    RtpCodecCapability entries in the mediaCodecs array of RouterOptions do not require  preferredPayloadType field (if unset, mediasoup will choose a random one). If given, make sure it's in the 96-127 range.
    */
    export interface RtpCodecCapability {

        /**	Media kind (“audio” or “video”).*/
        kind: MediaKind;
        
        /**The codec MIME media type/subtype (e.g. “audio/opus”, “video/VP8”).*/
        mimeType: string;

        /**	The preferred RTP payload type. This value only can be avoided when used in RouterOptions. If given, make sure it's in the 96-127 range.*/
        preferredPayloadType?: number;

        /**Codec clock rate expressed in Hertz.*/
        clockRate: number;

        /**The number of channels supported (e.g. two for stereo). Just for audio.	Default 1*/
        channels?: number;

        /**Codec specific parameters. Some parameters (such as “packetization-mode” and “profile-level-id” in H264 or “profile-id” in VP9) are critical for codec matching.*/
        parameters?: any;

    }

    /**Provides information relating to supported header extensions. The list of RTP header extensions supported by mediasoup is defined in the supportedRtpCapabilities.js file.
     * 
     * mediasoup does not currently support encrypted RTP header extensions.
     * The direction field is just present in mediasoup RTP capabilities (retrieved via router.rtpCapabilities or mediasoup.getSupportedRtpCapabilities()). It's ignored if present in endpoints' RTP capabilities.*/
    export interface RtpHeaderExtension {

        /**Media kind (“audio” or “video”). If unset, it's valid for all kinds.	Default any media kind*/
        kind?: MediaKind;

        /**The URI of the RTP header extension, as defined in RFC 5285.*/
        uri: string;

        /**	The preferred numeric identifier that goes in the RTP packet. Must be unique.*/
        preferredId: number;

        /**	If true, it is preferred that the value in the header be encrypted as per RFC 6904. Default false */
        preferredEncrypt?: boolean;

        /** If “sendrecv”, mediasoup supports sending and receiving this RTP extension. “sendonly” means that mediasoup can send (but not receive) it. “recvonly” means that mediasoup can receive (but not send) it.*/
        direction?: "sendrecv" | "sendonly" | "recvonly" | "inactive";
    }
    
    /**H264 codec matching rules are complex and involve inspection of the following parameters (see the RFC 6184 for more details)*/
    export interface H264 {
        
        /**means that the single NAL mode must be used. 1 means that the non-interleaved mode must be used.	Default 0 */
        "packetization-mode"?: number;

        /**	Indicates the default sub-profile and the default level of the stream.*/
        "profile-level-id": string;

        /**	Indicates whether level asymmetry is allowed. Default 0 */
        "level-asymmetry-allowed"?: number;
    }

    /**H264 codec matching rules are complex and involve inspection of the following parameters (see the RFC 6184 for more details)*/
    export interface VP9 {
        
        /**	VP9 coding profile (more info). Supported values are 0 and 2. Default 0*/
        "profile-id"?: string;
    }

    export interface OPUS {
        
        /**If 1, mediasoup will use the worst packet fraction lost in the RTCP Receiver Report received from the consuming endpoints and use it into the Receiver Report that mediasoup sends to the OPUS producer endpoint. This will force it to generate more in-band FEC into the OPUS packets to accomodate to the worst receiver. Default 0 */
        useinbandfec?: number;

        /**If 1, mediasoup will not consider the stream as inactive when there is no RTP traffic. Same behavior is achieved by indicating dtx: true in the corresponding encoding in the RTP send parameters. Default 0 */
        usedtx?: number;
    }

    export interface MediaSoupConfig {
        worker: WorkerSettings;
        router: RouterOptions;
        webRtcTransport?: WebRtcTransportOptions;
        plainRtpTransport?: PlainRtpTransportOptions;
    }
}
